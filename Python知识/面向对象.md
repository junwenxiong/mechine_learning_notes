# 2.面向对象
## 2.1 定义方法
* 类中的方法在定义时必须都传入self参数，第一个参数永远都是实例变量self。而且在调用时，不需要传入该参数。其他的参数都是可自己加的。


## 2.2 定义变量
**1.** 私有变量：在变量名前加两个_下划线就变成了私有变量了，如__xxx，只有内部可以访问，外部不能访问。当然，想要访问也是可以的，不过需要访问lisa._Student__name这样就行了。

**2.** 特殊变量：变量名类似于__XXX__的，他是可以直接访问的，如果是_name这样的变量的话，其意思就是：‘虽然我可以被访问，但是，请把我视为私有变量，不要随意访问’。

3. 以单下划线开头(如：_foo)：代表不能直接访问的类属性，需通过类提供的接口进行访问。

## 2.3 父类与子类
**1.** 一个.py文件是一个模块，一个模块中可以有多个类，既可以写入父类又可以写入子类

**2.** 如果子类和父类不在同一个文件里面，你可以把父类封装成模块，然后引入子类中继承。不存在无法继承的问题。甚至在不同的包里面也可以继承，只要你的文件路径对。


## 2.4 动态语言VS静态语言
**1.** 静态语言，如java,如果需要传入Animal类型，则传入的对象必须是Animal类型或是其子类，否则无法run()方法，此方法在Animal.py文件中。

**2.** 而对于动态语言，如python，则不一定需要传入Animal类型，只需要对象中含有run()方法即可，也被称之为“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。

## 2.5 type与isintance
**1.** 能用type判断的基本类型也能够用isintance判断

**2.** 不过总是优先使用isintance方法，可以将其指定类型及其子类’一网打尽‘


## 2.6 实例属性与类属性
**1.** 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的对应属性，但是类属性从未消失。

## 2.7 __slots__限制实例的属性
**1.**  比如，只允许对Student实例添加name和age属性 ，添加其他属性就会报错

**2.** slots只对当前类实例起作用，对继承其的子类是不起作用的


## 2.8 @property方法
**1.** @property为一个装饰器，负责把一个方法变成属性调用的。

**2.** 把一个getter方法变成属性，    只需要加上@property就行了，并且创建了另一个装饰器@score.setter,负责把一个setter方法变成属性赋值。

## 2.9 多重继承MixIn 
**1.** 设计类的继承关系，其目的就是给一个类增加多个功能。

